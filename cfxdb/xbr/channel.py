##############################################################################
#
#                        Crossbar.io FX
#     Copyright (C) Crossbar.io Technologies GmbH. All rights reserved.
#
##############################################################################

import pprint

import flatbuffers
import numpy as np
from cfxdb import unpack_uint256, pack_uint256
from cfxdb.gen.xbr import PaymentChannelType as PaymentChannelTypeGen, PaymentChannelState as PaymentChannelStateGen, \
    PayingChannelRequestState as PayingChannelRequestStateGen, PayingChannelRequest as PayingChannelRequestGen, \
    PaymentChannel as PaymentChannelGen, PaymentChannelBalance as PaymentChannelBalanceGen
from zlmdb import table, MapBytes16FlatBuffers, MapBytes20Bytes16, MapBytes20FlatBuffers, MapBytes20TimestampBytes20

PaymentChannelType = PaymentChannelTypeGen.PaymentChannelType
PaymentChannelState = PaymentChannelStateGen.PaymentChannelState
PayingChannelRequestState = PayingChannelRequestStateGen.PayingChannelRequestState


class _PayingChannelRequestGen(PayingChannelRequestGen.PayingChannelRequest):
    """
    Expand methods on the class code generated by flatc.

    FIXME: come up with a PR for flatc to generated this stuff automatically.
    """
    @classmethod
    def GetRootAsPayingChannelRequest(cls, buf, offset):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = _PayingChannelRequestGen()
        x.Init(buf, n + offset)
        return x

    def RequestAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def MarketAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def SenderAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def DelegateAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def RecipientAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def AmountAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def TimeoutAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def ChannelAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None


class PayingChannelRequest(object):
    """
    ``XBRPayingChannelRequest`` record/event database object.

    Request to have the market maker open a paying channel (which is a payment channel from the market maker to the data seller).
    """
    def __init__(self, from_fbs=None):
        self._from_fbs = from_fbs

        self._request = None
        self._timestamp = None
        self._market = None
        self._sender = None
        self._delegate = None
        self._recipient = None
        self._amount = None
        self._timeout = None
        self._state = None
        self._error_msg = None
        self._channel = None

    def marshal(self) -> dict:
        obj = {
            'request': bytes(self.request) if self.request else None,
            'timestamp': self.timestamp,
            'market': bytes(self.market) if self.market else None,
            'sender': bytes(self.sender) if self.sender else None,
            'delegate': bytes(self.delegate) if self.delegate else None,
            'recipient': bytes(self.recipient) if self.recipient else None,
            'amount': self.amount,
            'timeout': self.timeout,
            'state': self.state,
            'error_msg': self.error_msg,
            'channel': self.channel,
        }
        return obj

    def __str__(self):
        return '\n{}\n'.format(pprint.pformat(self.marshal()))

    @property
    def request(self) -> bytes:
        """
        ID of the paying channel request.
        """
        if self._request is None and self._from_fbs:
            if self._from_fbs.RequestLength():
                self._request = self._from_fbs.RequestAsBytes()
        return self._request

    @request.setter
    def request(self, value: bytes):
        assert value is None or type(value) == bytes
        self._request = value

    @property
    def timestamp(self) -> np.datetime64:
        """
        Offer transaction time (epoch time in ns)
        """
        if self._timestamp is None and self._from_fbs:
            self._timestamp = np.datetime64(self._from_fbs.Timestamp(), 'ns')
        return self._timestamp

    @timestamp.setter
    def timestamp(self, value):
        assert value is None or isinstance(value, np.datetime64)
        self._timestamp = value

    @property
    def market(self) -> bytes:
        """
        ID of the market this request for a paying channel is associated with.
        """
        if self._market is None and self._from_fbs:
            if self._from_fbs.MarketLength():
                self._market = self._from_fbs.MarketAsBytes()
        return self._market

    @market.setter
    def market(self, value: bytes):
        assert value is None or type(value) == bytes
        self._market = value

    @property
    def sender(self) -> bytes:
        """
        The sender address of the Ethereum transaction submitting the paying channel request.
        """
        if self._sender is None and self._from_fbs:
            if self._from_fbs.SenderLength():
                self._sender = self._from_fbs.SenderAsBytes()
        return self._sender

    @sender.setter
    def sender(self, value):
        assert value is None or type(value) == bytes
        self._sender = value

    @property
    def delegate(self) -> bytes:
        """
        The address of the buyer delegate allowed to consume the payment channel balance.
        """
        if self._delegate is None and self._from_fbs:
            if self._from_fbs.DelegateLength():
                self._delegate = self._from_fbs.DelegateAsBytes()
        return self._delegate

    @delegate.setter
    def delegate(self, value: bytes):
        assert value is None or type(value) == bytes
        self._delegate = value

    @property
    def recipient(self) -> bytes:
        """
        The ultimate recipient of this payment channel (for a XBR buyer, this will be the XBR market maker address; for a XBR seller, this will be the seller address).
        """
        if self._recipient is None and self._from_fbs:
            if self._from_fbs.RecipientLength():
                self._recipient = self._from_fbs.RecipientAsBytes()
        return self._recipient

    @recipient.setter
    def recipient(self, value: bytes):
        assert value is None or type(value) == bytes
        self._recipient = value

    @property
    def amount(self) -> int:
        """
        The initial amount in the (off-chain) payment channel.
        """
        if self._amount is None and self._from_fbs:
            if self._from_fbs.AmountLength():
                _amount = self._from_fbs.AmountAsBytes()
                self._amount = unpack_uint256(bytes(_amount))
            else:
                self._amount = 0
        return self._amount

    @amount.setter
    def amount(self, value: int):
        assert value is None or type(value) == int, 'amount must be int, was: {}'.format(value)
        self._amount = value

    @property
    def timeout(self) -> int:
        """
        The timeout knob for a non-cooperative close of the payment channel.

        :return:
        """
        if self._timeout is None and self._from_fbs:
            if self._from_fbs.TimeoutLength():
                _timeout = self._from_fbs.TimeoutAsBytes()
                self._timeout = unpack_uint256(bytes(_timeout))
            else:
                self._timeout = 0
        return self._timeout

    @timeout.setter
    def timeout(self, value: int):
        assert value is None or type(value) == int, 'timeout must be int, was: {}'.format(value)
        self._timeout = value

    @property
    def state(self) -> int:
        """
        Paying channel request current state.
        """
        if self._state is None and self._from_fbs:
            self._state = self._from_fbs.State()
        return self._state

    @state.setter
    def state(self, value: int):
        assert type(value) == int, 'state must be int, was: {}'.format(value)
        self._state = value

    @property
    def error_msg(self) -> str:
        """
        When state is PayingChannelRequestState.FAILED, an optional error message.
        """
        if self._error_msg is None and self._from_fbs:
            error_msg = self._from_fbs.ErrorMsg()
            if error_msg:
                self._error_msg = error_msg.decode('utf8')
        return self._error_msg

    @error_msg.setter
    def error_msg(self, value: str):
        assert value is None or type(value) == str
        self._error_msg = value

    @property
    def channel(self) -> bytes:
        """
        When this request has been fulfilled, the address to the contract of the created payment channel (from the market maker to the data seller).
        """
        if self._channel is None and self._from_fbs:
            if self._from_fbs.ChannelLength():
                self._channel = self._from_fbs.ChannelAsBytes()
        return self._channel

    @channel.setter
    def channel(self, value: bytes):
        assert value is None or type(value) == bytes, 'value must be bytes, not "{}"'.format(type(value))
        self._channel = value

    @staticmethod
    def cast(buf):
        return PayingChannelRequest(_PayingChannelRequestGen.GetRootAsPayingChannelRequest(buf, 0))

    def build(self, builder):

        request = self.request
        if request:
            request = builder.CreateString(bytes(request))

        market = self.market
        if market:
            market = builder.CreateString(bytes(market))

        sender = self.sender
        if sender:
            sender = builder.CreateString(bytes(sender))

        delegate = self.delegate
        if delegate:
            delegate = builder.CreateString(bytes(delegate))

        recipient = self.recipient
        if recipient:
            recipient = builder.CreateString(bytes(recipient))

        amount = self.amount
        if amount:
            amount = builder.CreateString(pack_uint256(amount))

        timeout = self.timeout
        if timeout:
            timeout = builder.CreateString(pack_uint256(timeout))

        error_msg = self.error_msg
        if error_msg:
            error_msg = builder.CreateString(error_msg)

        channel = self.channel
        if channel:
            channel = builder.CreateString(bytes(channel))

        PayingChannelRequestGen.PayingChannelRequestStart(builder)

        if request:
            PayingChannelRequestGen.PayingChannelRequestAddRequest(builder, request)

        if self.timestamp:
            PayingChannelRequestGen.PayingChannelRequestAddTimestamp(builder, int(self.timestamp))

        if market:
            PayingChannelRequestGen.PayingChannelRequestAddMarket(builder, market)

        if sender:
            PayingChannelRequestGen.PayingChannelRequestAddSender(builder, sender)

        if delegate:
            PayingChannelRequestGen.PayingChannelRequestAddDelegate(builder, delegate)

        if recipient:
            PayingChannelRequestGen.PayingChannelRequestAddRecipient(builder, recipient)

        if amount:
            PayingChannelRequestGen.PayingChannelRequestAddAmount(builder, amount)

        if timeout:
            PayingChannelRequestGen.PayingChannelRequestAddTimeout(builder, timeout)

        if self.state:
            PayingChannelRequestGen.PayingChannelRequestAddState(builder, int(self.state))

        if error_msg:
            PayingChannelRequestGen.PayingChannelRequestAddErrorMsg(builder, error_msg)

        if channel:
            PayingChannelRequestGen.PayingChannelRequestAddChannel(builder, channel)

        final = PayingChannelRequestGen.PayingChannelRequestEnd(builder)

        return final


class _PaymentChannelGen(PaymentChannelGen.PaymentChannel):
    """
    Expand methods on the class code generated by flatc.

    FIXME: come up with a PR for flatc to generated this stuff automatically.
    """
    @classmethod
    def GetRootAsPaymentChannel(cls, buf, offset):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = _PaymentChannelGen()
        x.Init(buf, n + offset)
        return x

    def ChannelAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def MarketAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def SenderAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def DelegateAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def RecipientAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def AmountAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def OpenAtAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def ClosingAtAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def ClosedAtAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def CloseMmSigAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def CloseDelSigAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def CloseBalanceAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def ClosedTxAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None


class PaymentChannel(object):
    """
    ``XBRPaymentChannel`` record/event database object.

    XBR payment channel (from XBR consumer to XBR market maker) and XBR paying channels (from XBR market maker to XBR provider).
    """
    def __init__(self, from_fbs=None):
        self._from_fbs = from_fbs

        self._type = None
        self._channel = None
        self._market = None
        self._sender = None
        self._delegate = None
        self._recipient = None
        self._amount = None
        self._timeout = None
        self._state = None
        self._open_at = None
        self._closing_at = None
        self._closed_at = None

        self._close_mm_sig = None
        self._close_del_sig = None
        self._close_channel_seq = None
        self._close_balance = None
        self._close_is_final = None

        self._closed_tx = None

    def marshal(self) -> dict:
        obj = {
            'type': self.type,
            'channel': bytes(self.channel) if self.channel else None,
            'market': bytes(self.market) if self.market else None,
            'sender': bytes(self.sender) if self.sender else None,
            'delegate': bytes(self.delegate) if self.delegate else None,
            'recipient': bytes(self.recipient) if self.recipient else None,
            'amount': pack_uint256(self.amount) if self.amount else 0,
            'timeout': self.timeout,
            'state': self.state,
            'open_at': self.open_at,
            'closing_at': self.closing_at,
            'closed_at': self.closed_at,
            'close_mm_sig': bytes(self.close_mm_sig) if self.close_mm_sig else None,
            'close_del_sig': bytes(self.close_del_sig) if self.close_del_sig else None,
            'close_channel_seq': self.close_channel_seq,
            'close_is_final': self.close_is_final,
            'close_balance': self.close_balance,
            'closed_tx': bytes(self.closed_tx) if self.closed_tx else None,
        }
        return obj

    def __str__(self):
        return '\n{}\n'.format(pprint.pformat(self.marshal()))

    @property
    def type(self) -> int:
        """
        Channel type: payment channel (from XBR consumer to XBR market maker) or paying channel (from XBR market maker to XBR provider).
        """
        if self._type is None and self._from_fbs:
            self._type = self._from_fbs.Type()
        return self._type

    @type.setter
    def type(self, value: int):
        assert type(value) == int
        self._type = value

    @property
    def channel(self) -> bytes:
        """
        ID of the payment channel.
        """
        if self._channel is None and self._from_fbs:
            if self._from_fbs.ChannelLength():
                self._channel = self._from_fbs.ChannelAsBytes()
        return self._channel

    @channel.setter
    def channel(self, value: bytes):
        assert value is None or type(value) == bytes
        self._channel = value

    @property
    def market(self) -> bytes:
        """
        ID of the market this payment channel is associated with.
        """
        if self._market is None and self._from_fbs:
            if self._from_fbs.MarketLength():
                self._market = self._from_fbs.MarketAsBytes()
        return self._market

    @market.setter
    def market(self, value: bytes):
        assert value is None or type(value) == bytes
        self._market = value

    @property
    def sender(self) -> bytes:
        """
        Ethereum address of the sender (either XBR Consumer or XBR Market).
        """
        if self._sender is None and self._from_fbs:
            if self._from_fbs.SenderLength():
                self._sender = self._from_fbs.SenderAsBytes()
        return self._sender

    @sender.setter
    def sender(self, value: bytes):
        assert value is None or type(value) == bytes
        self._sender = value

    @property
    def delegate(self) -> bytes:
        """
        Ethereum address of the sender delegate (either XBR Consumer delegate or XBR Market delegate == market maker)
        """
        if self._delegate is None and self._from_fbs:
            if self._from_fbs.DelegateLength():
                self._delegate = self._from_fbs.DelegateAsBytes()
        return self._delegate

    @delegate.setter
    def delegate(self, value: bytes):
        assert value is None or type(value) == bytes
        self._delegate = value

    @property
    def recipient(self) -> bytes:
        """
        Ethereum address of the recipient (either XBR Market or XBR Provider)
        """
        if self._recipient is None and self._from_fbs:
            if self._from_fbs.RecipientLength():
                self._recipient = self._from_fbs.RecipientAsBytes()
        return self._recipient

    @recipient.setter
    def recipient(self, value: bytes):
        assert value is None or type(value) == bytes
        self._recipient = value

    @property
    def amount(self) -> int:
        """
        Amount of XBR tokens initially deposited into the payment channel.
        """
        if self._amount is None and self._from_fbs:
            if self._from_fbs.AmountLength():
                _amount = self._from_fbs.AmountAsBytes()
                self._amount = unpack_uint256(bytes(_amount))
            else:
                self._amount = 0
        return self._amount

    @amount.setter
    def amount(self, value: int):
        assert value is None or type(value) == int
        self._amount = value

    @property
    def timeout(self) -> int:
        """
        Payment channel (non-cooperative) closed timeout in blocks (on the blockchain).
        """
        if self._timeout is None and self._from_fbs:
            self._timeout = self._from_fbs.Timeout()
        return self._timeout

    @timeout.setter
    def timeout(self, value: int):
        assert type(value) == int
        self._timeout = value

    @property
    def state(self) -> int:
        """
        Current state of payment channel.
        """
        if self._state is None and self._from_fbs:
            self._state = self._from_fbs.State()
        return self._state

    @state.setter
    def state(self, value: int):
        assert type(value) == int
        self._state = value

    @property
    def open_at(self) -> int:
        """
        Block number (on the blockchain) when the payment channel was opened.
        """
        if self._open_at is None and self._from_fbs:
            if self._from_fbs.OpenAtLength():
                _open_at = self._from_fbs.OpenAtAsBytes()
                self._open_at = unpack_uint256(bytes(_open_at))
            else:
                self._open_at = 0
        return self._open_at

    @open_at.setter
    def open_at(self, value: int):
        assert value is None or type(value) == int
        self._open_at = value

    @property
    def closing_at(self) -> int:
        """
        Block number (on the blockchain) when the payment channel will close (at the latest).
        """
        if self._closing_at is None and self._from_fbs:
            if self._from_fbs.ClosingAtLength():
                _closing_at = self._from_fbs.ClosingAtAsBytes()
                self._closing_at = unpack_uint256(bytes(_closing_at))
            else:
                self._closed_at = 0
        return self._closing_at

    @closing_at.setter
    def closing_at(self, value: int):
        assert value is None or type(value) == int
        self._closing_at = value

    @property
    def closed_at(self) -> int:
        """
        Block number (on the blockchain) when the payment channel was finally closed.
        """
        if self._closed_at is None and self._from_fbs:
            if self._from_fbs.ClosedAtLength():
                _closed_at = self._from_fbs.ClosedAtAsBytes()
                self._closed_at = unpack_uint256(bytes(_closed_at))
            else:
                self._closed_at = 0
        return self._closed_at

    @closed_at.setter
    def closed_at(self, value: int):
        assert value is None or type(value) == int
        self._closed_at = value

    @property
    def close_mm_sig(self) -> int:
        """
        Closing signature by market maker.
        """
        if self._close_mm_sig is None and self._from_fbs:
            if self._from_fbs.CloseMmSigLength():
                self._close_mm_sig = self._from_fbs.CloseMmSigAsBytes()
        return self._close_mm_sig

    @close_mm_sig.setter
    def close_mm_sig(self, value: int):
        assert value is None or type(value) == bytes
        self._close_mm_sig = value

    @property
    def close_del_sig(self) -> bytes:
        """
        Closing signature by (seller or buyer) delegate.
        """
        if self._close_del_sig is None and self._from_fbs:
            if self._from_fbs.CloseDelSigLength():
                self._close_del_sig = self._from_fbs.CloseDelSigAsBytes()
        return self._close_del_sig

    @close_del_sig.setter
    def close_del_sig(self, value: bytes):
        assert value is None or type(value) == bytes
        self._close_del_sig = value

    @property
    def close_channel_seq(self) -> int:
        """
        Last off-chain, closing transaction: channel transaction sequence number.
        """
        if self._close_channel_seq is None and self._from_fbs:
            self._close_channel_seq = self._from_fbs.CloseChannelSeq()
        return self._close_channel_seq

    @close_channel_seq.setter
    def close_channel_seq(self, value: int):
        assert type(value) == int
        self._close_channel_seq = value

    @property
    def close_balance(self) -> int:
        """
        Remaining (closing) channel balance (XBR).
        """
        if self._close_balance is None and self._from_fbs:
            if self._from_fbs.CloseBalanceLength():
                _close_balance = self._from_fbs.CloseBalanceAsBytes()
                if _close_balance is not None:
                    self._close_balance = unpack_uint256(bytes(_close_balance))
                else:
                    self._close_balance = 0
            else:
                self._close_balance = 0
        return self._close_balance

    @close_balance.setter
    def close_balance(self, value: int):
        assert value is None or type(value) == int
        self._close_balance = value

    @property
    def close_is_final(self) -> bool:
        """
        Flag indication if close is final (happens immediately without a channel timeout).
        """
        if self._close_is_final is None and self._from_fbs:
            self._close_is_final = (self._from_fbs.CloseIsFinal() is True)
        return self._close_is_final

    @close_is_final.setter
    def close_is_final(self, value: bool):
        assert value is None or type(value) == bool
        self._close_is_final = value

    @property
    def closed_tx(self) -> bytes:
        """
        When channel was finally closed on-chain, the Ethereum transaction ID.
        """
        if self._closed_tx is None and self._from_fbs:
            if self._from_fbs.ClosedTxLength():
                self._closed_tx = self._from_fbs.ClosedTxAsBytes()
        return self._closed_tx

    @closed_tx.setter
    def closed_tx(self, value: bytes):
        assert value is None or type(value) == bytes
        self._closed_tx = value

    @staticmethod
    def cast(buf):
        return PaymentChannel(_PaymentChannelGen.GetRootAsPaymentChannel(buf, 0))

    def build(self, builder):

        channel = self.channel
        if channel:
            channel = builder.CreateString(bytes(channel))

        market = self.market
        if market:
            market = builder.CreateString(bytes(market))

        sender = self.sender
        if sender:
            sender = builder.CreateString(bytes(sender))

        delegate = self.delegate
        if delegate:
            delegate = builder.CreateString(bytes(delegate))

        recipient = self.recipient
        if recipient:
            recipient = builder.CreateString(bytes(recipient))

        amount = self.amount
        if amount:
            amount = builder.CreateString(pack_uint256(amount))

        open_at = self.open_at
        if open_at:
            open_at = builder.CreateString(pack_uint256(open_at))

        closing_at = self.closing_at
        if closing_at:
            closing_at = builder.CreateString(pack_uint256(closing_at))

        closed_at = self.closed_at
        if closed_at:
            closed_at = builder.CreateString(pack_uint256(closed_at))

        close_mm_sig = self.close_mm_sig
        if close_mm_sig:
            close_mm_sig = builder.CreateString(bytes(close_mm_sig))

        close_del_sig = self.close_del_sig
        if close_del_sig:
            close_del_sig = builder.CreateString(bytes(close_del_sig))

        close_balance = self.close_balance
        if close_balance:
            close_balance = builder.CreateString(pack_uint256(close_balance))

        closed_tx = self.closed_tx
        if closed_tx:
            closed_tx = builder.CreateString(bytes(closed_tx))

        PaymentChannelGen.PaymentChannelStart(builder)

        if self.type:
            PaymentChannelGen.PaymentChannelAddType(builder, int(self.type))

        if channel:
            PaymentChannelGen.PaymentChannelAddChannel(builder, channel)

        if market:
            PaymentChannelGen.PaymentChannelAddMarket(builder, market)

        if sender:
            PaymentChannelGen.PaymentChannelAddSender(builder, sender)

        if delegate:
            PaymentChannelGen.PaymentChannelAddDelegate(builder, delegate)

        if recipient:
            PaymentChannelGen.PaymentChannelAddRecipient(builder, recipient)

        if amount:
            PaymentChannelGen.PaymentChannelAddAmount(builder, amount)

        PaymentChannelGen.PaymentChannelAddTimeout(builder, self.timeout)

        if self.state:
            PaymentChannelGen.PaymentChannelAddState(builder, int(self.state))

        if open_at:
            PaymentChannelGen.PaymentChannelAddOpenAt(builder, open_at)

        if closing_at:
            PaymentChannelGen.PaymentChannelAddClosingAt(builder, closing_at)

        if closed_at:
            PaymentChannelGen.PaymentChannelAddClosedAt(builder, closed_at)

        if close_mm_sig:
            PaymentChannelGen.PaymentChannelAddCloseMmSig(builder, close_mm_sig)

        if close_del_sig:
            PaymentChannelGen.PaymentChannelAddCloseDelSig(builder, close_del_sig)

        if self.close_channel_seq:
            PaymentChannelGen.PaymentChannelAddCloseChannelSeq(builder, self.close_channel_seq)

        if close_balance:
            PaymentChannelGen.PaymentChannelAddCloseBalance(builder, close_balance)

        if self.close_is_final:
            PaymentChannelGen.PaymentChannelAddCloseIsFinal(builder, self.close_is_final)

        if closed_tx:
            PaymentChannelGen.PaymentChannelAddClosedTx(builder, closed_tx)

        final = PaymentChannelGen.PaymentChannelEnd(builder)

        return final


@table('8ce6b28c-ad8f-456e-a947-1b19e9b19247',
       build=PayingChannelRequest.build,
       cast=PayingChannelRequest.cast)
class PayingChannelRequests(MapBytes16FlatBuffers):
    """
    XBR paying channel requests by ``paying_channel_adr``.

    Map :class:`zlmdb.MapBytes20FlatBuffers` from ``paying_channel_adr`` to :class:`cfxdb.xbr.PayingChannelRequest`
    """


@table('0b3f5f33-165c-4f52-9e4a-23d0edc8c3a6')
class IndexPayingChannelRequestByRecipient(MapBytes20Bytes16):
    """
    Index: ``recipient_adr -> paying_channel_request_id``.
    """


@table('b3d01946-85ae-49f3-ad96-b78194eb82fe', build=PaymentChannel.build, cast=PaymentChannel.cast)
class PaymentChannels(MapBytes20FlatBuffers):
    """
    XBR payment channels by ``payment_channel_adr``.

    Map :class:`zlmdb.MapBytes20FlatBuffers` from ``payment_channel_adr`` to :class:`cfxdb.xbr.PaymentChannel`
    """


@table('cffd5253-72f8-41a9-8b76-5e6ff3654e67')
class IndexPaymentChannelByDelegate(MapBytes20TimestampBytes20):
    """
    Index: ``(delegate_adr, created_timestamp) -> payment_channel_adr``
    """


@table('4e7e7c8d-db0d-4dea-8409-ac8f21ce1e10', build=PaymentChannel.build, cast=PaymentChannel.cast)
class PayingChannels(MapBytes20FlatBuffers):
    """
    XBR paying channels by ``paying_channel_adr``.

    Map :class:`zlmdb.MapBytes32FlatBuffers` from ``paying_channel_adr`` to :class:`cfxdb.xbr.PaymentChannel`
    """


@table('cee954be-fdb2-43cc-8891-529d6c7a0c3b')
class IndexPayingChannelByDelegate(MapBytes20TimestampBytes20):
    """
    Index: ``(delegate_adr, created_timestamp) -> paying_channel_adr``
    """


@table('655a9d5f-0bdf-4c2a-8102-208f6da4a566')
class IndexPayingChannelByRecipient(MapBytes20TimestampBytes20):
    """
    Index: ``(recipient_adr, created_timestamp) -> paying_channel_adr``
    """


class _PaymentChannelBalanceGen(PaymentChannelBalanceGen.PaymentChannelBalance):
    """
    Expand methods on the class code generated by flatc.

    FIXME: come up with a PR for flatc to generated this stuff automatically.
    """
    @classmethod
    def GetRootAsPaymentChannelBalance(cls, buf, offset):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = _PaymentChannelBalanceGen()
        x.Init(buf, n + offset)
        return x

    def RemainingAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None

    def InflightAsBytes(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            _off = self._tab.Vector(o)
            _len = self._tab.VectorLen(o)
            return memoryview(self._tab.Bytes)[_off:_off + _len]
        return None


class PaymentChannelBalance(object):
    """
    XBR payment channel current (off-chain) balance. The sum of ``Balance.remaining`` and ``Balance.inflight`` equals ``PaymentChannel.amount``.
    """
    def __init__(self, from_fbs=None):
        self._from_fbs = from_fbs

        self._remaining = None
        self._inflight = None
        self._seq = None

    @staticmethod
    def parse(data: dict):
        assert type(data) == dict

        obj = PaymentChannelBalance()

        if 'remaining' in data:
            remaining = data['remaining']
            assert type(remaining) == bytes and len(remaining) == 32
            obj._remaining = unpack_uint256(remaining)

        if 'inflight' in data:
            inflight = data['inflight']
            assert type(inflight) == bytes and len(inflight) == 32
            obj._inflight = unpack_uint256(inflight)

        if 'seq' in data:
            seq = data['seq']
            assert type(seq) == int
            obj._seq = unpack_uint256(seq)

        return obj

    def marshal(self) -> dict:
        obj = {
            'remaining': pack_uint256(self.remaining) if self.remaining else 0,
            'inflight': pack_uint256(self.inflight) if self.inflight else 0,
            'seq': self.seq or 0
        }
        return obj

    def __str__(self):
        return '\n{}\n'.format(pprint.pformat(self.marshal()))

    @property
    def remaining(self) -> int:
        """
        Amount of XBR tokens currently remaining in the payment channel.
        """
        if self._remaining is None and self._from_fbs:
            if self._from_fbs.RemainingLength():
                _remaining = self._from_fbs.RemainingAsBytes()
                self._remaining = unpack_uint256(bytes(_remaining))
            else:
                self._remaining = 0
        return self._remaining

    @remaining.setter
    def remaining(self, value: int):
        assert value is None or type(value) == int
        self._remaining = value

    @property
    def inflight(self) -> int:
        """
        Amount of XBR tokens reserved to in-flight purchase transactions.
        """
        if self._inflight is None and self._from_fbs:
            if self._from_fbs.InflightLength():
                _inflight = self._from_fbs.InflightAsBytes()
                self._inflight = unpack_uint256(bytes(_inflight))
            else:
                self._inflight = 0
        return self._inflight

    @inflight.setter
    def inflight(self, value: int):
        assert value is None or type(value) == int
        self._inflight = value

    @property
    def seq(self) -> int:
        """
        Sequence number of transactions on this balance starting from 0 when the payment channel is created.
        """
        if self._seq is None and self._from_fbs:
            self._seq = self._from_fbs.Seq()
        return self._seq or 0

    @seq.setter
    def seq(self, value: int):
        assert value is None or type(value) == int
        self._seq = value

    @staticmethod
    def cast(buf):
        return PaymentChannelBalance(_PaymentChannelBalanceGen.GetRootAsPaymentChannelBalance(buf, 0))

    def build(self, builder):

        remaining = self.remaining
        if remaining:
            remaining = builder.CreateString(pack_uint256(remaining))

        inflight = self.inflight
        if inflight:
            inflight = builder.CreateString(pack_uint256(inflight))

        PaymentChannelBalanceGen.PaymentChannelBalanceStart(builder)

        if remaining:
            PaymentChannelBalanceGen.PaymentChannelBalanceAddRemaining(builder, remaining)

        if inflight:
            PaymentChannelBalanceGen.PaymentChannelBalanceAddInflight(builder, inflight)

        if self.seq:
            PaymentChannelBalanceGen.PaymentChannelBalanceAddSeq(builder, self.seq)

        final = PaymentChannelBalanceGen.PaymentChannelBalanceEnd(builder)

        return final


@table('878ac002-a830-488b-bfe9-f06371b8eecb',
       build=PaymentChannelBalance.build,
       cast=PaymentChannelBalance.cast)
class PaymentChannelBalances(MapBytes20FlatBuffers):
    """
    XBR payment channels current balances by ``payment_channel_adr``.

    Map :class:`zlmdb.MapBytes20FlatBuffers` from ``payment_channel_adr`` to :class:`cfxdb.xbr.Balance`
    """


@table('c0931d5d-6d5d-4f9c-b2a3-29664a0f4c07',
       build=PaymentChannelBalance.build,
       cast=PaymentChannelBalance.cast)
class PayingChannelBalances(MapBytes20FlatBuffers):
    """
    XBR paying channels current balances by ``paying_channel_adr``.

    Map :class:`zlmdb.MapBytes20FlatBuffers` from ``paying_channel_adr`` to :class:`cfxdb.xbr.Balance`
    """
